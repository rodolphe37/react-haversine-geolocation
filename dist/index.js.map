{"version":3,"sources":["../src/useGeolocationManager.ts","../src/utils.ts"],"sourcesContent":["import { useState, useCallback } from \"react\";\nimport { getDistanceInMeters } from \"./utils.js\";\nimport { GeolocationOptions, type TLocation, type TLocationHistory } from \"./types.js\";\n\nexport function useGeolocationManager({\n  distanceThreshold = 100,\n  loadHistory,\n  saveHistory,\n}: GeolocationOptions) {\n  const [history, setHistory] = useState<TLocationHistory>({ locations: [] });\n\n  // Charger l'historique au montage\n  const init = useCallback(async () => {\n    const existing = await loadHistory();\n    if (existing) {\n      setHistory(existing);\n    }\n  }, [loadHistory]);\n\n  // Ajouter une nouvelle location\n  const addLocation = useCallback(\n    async (newLocation: TLocation) => {\n      let updatedHistory: TLocationHistory = { ...history };\n\n      const lastLocation = updatedHistory.locations.at(-1);\n\n      let isSameCoords = false;\n\n      if (lastLocation) {\n        const distance = getDistanceInMeters(\n          lastLocation.coords.latitude,\n          lastLocation.coords.longitude,\n          newLocation.coords.latitude,\n          newLocation.coords.longitude\n        );\n\n        isSameCoords = distance < distanceThreshold;\n      }\n\n      if (isSameCoords && lastLocation) {\n        // juste mettre à jour le timestamp\n        lastLocation.timestamp = newLocation.timestamp;\n      } else {\n        updatedHistory.locations.push(newLocation);\n      }\n\n      setHistory(updatedHistory);\n      await saveHistory(updatedHistory);\n    },\n    [history, distanceThreshold, saveHistory]\n  );\n\n  return {\n    history,\n    init,\n    addLocation,\n  };\n}\n","// Fonction Haversine : distance en mètres entre deux points GPS\nexport function getDistanceInMeters(\n  lat1: number,\n  lon1: number,\n  lat2: number,\n  lon2: number\n): number {\n  const R = 6371000; // Rayon de la Terre en mètres\n  const dLat = ((lat2 - lat1) * Math.PI) / 180;\n  const dLon = ((lon2 - lon1) * Math.PI) / 180;\n  const a =\n    Math.sin(dLat / 2) ** 2 +\n    Math.cos((lat1 * Math.PI) / 180) *\n      Math.cos((lat2 * Math.PI) / 180) *\n      Math.sin(dLon / 2) ** 2;\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n}\n"],"mappings":";AAAA,SAAS,UAAU,mBAAmB;;;ACC/B,SAAS,oBACd,MACA,MACA,MACA,MACQ;AACR,QAAM,IAAI;AACV,QAAM,QAAS,OAAO,QAAQ,KAAK,KAAM;AACzC,QAAM,QAAS,OAAO,QAAQ,KAAK,KAAM;AACzC,QAAM,IACJ,KAAK,IAAI,OAAO,CAAC,KAAK,IACtB,KAAK,IAAK,OAAO,KAAK,KAAM,GAAG,IAC7B,KAAK,IAAK,OAAO,KAAK,KAAM,GAAG,IAC/B,KAAK,IAAI,OAAO,CAAC,KAAK;AAC1B,QAAM,IAAI,IAAI,KAAK,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,KAAK,IAAI,CAAC,CAAC;AACvD,SAAO,IAAI;AACb;;;ADbO,SAAS,sBAAsB;AAAA,EACpC,oBAAoB;AAAA,EACpB;AAAA,EACA;AACF,GAAuB;AACrB,QAAM,CAAC,SAAS,UAAU,IAAI,SAA2B,EAAE,WAAW,CAAC,EAAE,CAAC;AAG1E,QAAM,OAAO,YAAY,YAAY;AACnC,UAAM,WAAW,MAAM,YAAY;AACnC,QAAI,UAAU;AACZ,iBAAW,QAAQ;AAAA,IACrB;AAAA,EACF,GAAG,CAAC,WAAW,CAAC;AAGhB,QAAM,cAAc;AAAA,IAClB,OAAO,gBAA2B;AAChC,UAAI,iBAAmC,EAAE,GAAG,QAAQ;AAEpD,YAAM,eAAe,eAAe,UAAU,GAAG,EAAE;AAEnD,UAAI,eAAe;AAEnB,UAAI,cAAc;AAChB,cAAM,WAAW;AAAA,UACf,aAAa,OAAO;AAAA,UACpB,aAAa,OAAO;AAAA,UACpB,YAAY,OAAO;AAAA,UACnB,YAAY,OAAO;AAAA,QACrB;AAEA,uBAAe,WAAW;AAAA,MAC5B;AAEA,UAAI,gBAAgB,cAAc;AAEhC,qBAAa,YAAY,YAAY;AAAA,MACvC,OAAO;AACL,uBAAe,UAAU,KAAK,WAAW;AAAA,MAC3C;AAEA,iBAAW,cAAc;AACzB,YAAM,YAAY,cAAc;AAAA,IAClC;AAAA,IACA,CAAC,SAAS,mBAAmB,WAAW;AAAA,EAC1C;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;","names":[]}